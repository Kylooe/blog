- react/vue组件生命周期

  vue和react都是定义了一个抽象类来生成相应组件的，vue是通过new一个Vue实例，而react是继承React.Component。组件实例的生命周期基本都是大同小异的：

  1. 组件实例被创建和插入DOM

     | React                                    | Vue          |                |
     | :--------------------------------------- | ------------ | -------------- |
     |                                          | beforeCreate | 初始化事件的生命周期     |
     | constructor: getDefaultProps, getInitialState | created      | 初始化相关数据        |
     | componentWillMount                       | beforeMount  | 实例被挂载到HTML前    |
     | render                                   | 生成vm.$el     | 关联DOM元素(挂载)并渲染 |
     | componentDidMount                        | Mounted      | 已挂载至页面，初始化完成   |

  2. 组件更新阶段

     | React                     | Vue          |                                |
     | ------------------------- | ------------ | ------------------------------ |
     | componentWillReceiveProps |              | 传入的props发生改变，触发                |
     | shouldComponentUpdate     |              | state改变或props更改导致state改变并影响到视图 |
     | componentWillUpdate       | beforeUpdate | 数据变化并影响视图，需要重新render           |
     | componentDidUpdate        | updated      | Virtual DOM重新渲染完毕              |

  3. 组件卸载

     | React                | Vue           |                    |
     | -------------------- | ------------- | ------------------ |
     | componentWillUnmount | beforeDestroy | 组件将被卸载和销毁          |
     |                      | destroyed     | 观察者、子组件、监听器等等都卸载完毕 |

- 如何根据优先级获取资源如图片

  用onload()去先加载优先的资源？加载完再callback加载后面的资源？

- ES6模块

  首先ES6的模块就已经做到了按需加载：`import { foo, bar } from 'xxx';`，这种加载称为编译时加载或静态加载，而非使用`require('xxx')`的运行时加载。

- 公司目前项目的优化

  1. 对于前端的静态资源利用了缓存进行优化，同时通过构建版本号为静态资源请求添加query来更改资源链接从而更新缓存。但这种做法的存在明显的问题：

    + 只修改其中一个文件再次构建时所有资源的请求地址都会被改变，用户再度访问时其他没有被修改过的资源缓存也全都一并失效了，浏览器缓存的利用率低。
    + 使用这种优化方法上线时是覆盖式发布，假设更改了某个html以及某个js，这两个资源的更新有先后顺序，在期间的时间过程内新用户进行访问，会得到两个结果：先覆盖更新html，js仍为旧资源，可能DOM树的结构已经完全不同了，旧js不适用，无法生效，页面错误；先更新js，html仍为旧资源，同样是上面的原因，页面错误。因此一个常见的做法是半夜更新上线维护，然而治标不治本。

    对此可以优化的方法是采用基于文件内容的地址更新机制而非更新版本号，即不是使用类似于`main.js?v0.0.1`而是`main_458842e78.js`。后缀的字符是根据js的具体内容通过hash运算所得，文件内容发生更改时才会改变。

    > 什么是hash运算？简单来说，即是一段特定的数据内容通过hash算法输出为另一段固定长度的数据。

    因为通过这种方法上线不是覆盖式的，所以可以先上线静态资源再上线html，而且版本为文件内容的hash所以所有静态资源可以开启永久缓存，更新了内容的资源才会缓存失效。就相当于先部署全部需改更改的静态资源，此时cdn节点里有两个css文件，一新一旧，文件名的hash后缀不同，在新html上线之前css用的仍然是旧的，再发布引用资源的hash值为新值的新html，就可以避免先上线其中一方都会导致页面错误的问题了。同时因此要进行版本回退时也无需回滚css和js等资源文件，因为不是覆盖式部署嘛！只要回滚旧版本html就好。

  2. 对于CSS和js目前是分模块写好再合并引用到相应的main中，无法解决按需加载，比如首页不需要subpage的样式资源、某些页面需要bootstrap有些没有等等。静态资源的优化主要是合并请求、按需加载、避免重复加载，最好还能实现就近依赖以及开发过程中就近引用但输出html时css和js仍分别在头部和尾部。

     其实这方面目前已经处理了，比如css和js以及相应的页面部分都有分为各个block，但具体细节仍未做好，如用的第三方库类都全部合并输出为vendor.js，自行编写的全部都是main.js之类，但如果要细分也比较麻烦，要细可以很细，一个页面中能有起码上十个组件，相对而言按需加载也容易有增多http请求的影响，所以这个优化的度还是有待考究的。

     这个其实是有关打包策略的问题了，一个思路是高频修改的与低频修改的分开打包。以及webpack好像就是解决这个痛点的？

- 目前的模式

  后端渲染页面，前端直接写后端模板，而非输出HTML交付后端再由后端模板化。这样的架构决定了开发过程中一定是后端重于前端，一旦后端配置出错，前端也无法正常开发了只能等待救援。同时页面中交织着非前端代码，互相干扰，而且前后端职责不清晰。

- node如何做中间层来实现前后端分离

  现在看来大概是用node编写兼容后端模板语法的模板，再用模拟数据进行渲染了，其他例如AJAX数据模拟等也可以通过node来实现。